import netsquid as ns

from netsquid.protocols import NodeProtocol
from netsquid.components import Clock
from netsquid.components.qsource import SourceStatus

import sys
scriptpath = "lib/"
sys.path.append(scriptpath)
from lib.functions import rng_bin_lst, SinglePhotonSource



class AliceProtocol(NodeProtocol):
    """
    Protocol to run on Alice-type node in point-to-point BB84.

    Attributes:
        node            netsquid.components.node.Node object to host protocol
        photon_count    number of photons to be transmitted
        port_qo_name    name of quantum out port on `node`
        port_co_name    name of classical out port on `node`
        port_ci_name    name of classical in port on `node`
        basis_list      list of basis choices for photon string (0 = Z-basis, 1 = X-basis)
        bit_list        list of bit choices for photon string
        key             storage for key output
        source_Qlist    list of qubits emitted by attached photon source
        source_freq     frequency of attached photon source in Hz

    Parameters:
        portNames       list of node ports to be stored in protocol
        sourceEff       efficiency of attached photon source
    """


    def __init__(self, node, photonCount, sourceFreq, portNames=["A.Q.Out","A,C.Out","A.C.In"], sourceEff=1):
        super().__init__()
        self.node         = node
        self.photon_count = photonCount
        self.port_qo_name = portNames[0]
        self.port_co_name = portNames[1]
        self.port_ci_name = portNames[2]
        self.basis_list   = rng_bin_lst(photonCount)
        self.bit_list     = rng_bin_lst(photonCount)

        self.key          = []

        # attaching a lib.functions.SinglePhotonSource object external to the node
        self.a_source     = SinglePhotonSource("[A: SPS]", sourceFreq, efficiency=sourceEff, status=SourceStatus.EXTERNAL)
        # function to handle source output
        self.a_source.ports["qout0"].bind_output_handler(self.store_source_output)
        
        self.source_Qlist = []
        self.source_freq  = sourceFreq


    def store_source_output(self, qubit):
        """
        Store qubit (photon) output in list to be batched to output port via the self.source_Qlist property
        
        Parameters:
            qubit       photon generated by attached SPS
        """
        self.source_Qlist.append(qubit.items[0])
        if len(self.source_Qlist) % 100 == 0:
            print(f"[Alice] Stored {len(self.source_Qlist)} photons so far")

        # if our quantum outbound list is the same size as the photon count we release it and clear
        if len(self.source_Qlist) == self.photon_count:
            print("[Alice] Reached photon_count, encoding and sending batch")
            self.encode_and_send()
            self.source_Qlist = []


    def encode_and_send(self):
        """
        Encode basis and bit and send batch on quantum port
        """
        for i, q in enumerate(self.source_Qlist):
            basis, bit = self.basis_list[i], self.bit_list[i]
            if basis: ns.qubits.operate(q, ns.H)
            if bit: ns.qubits.operate(q, ns.X)
        self.node.ports[self.port_qo_name].tx_output(self.source_Qlist)


    def basis_reconciliation(self):
        """
        Send basis choices to Bob, receive his and sift common bits into self.key
        """
        print("[Alice] Sending my basis list first...")
        # send to Bob
        self.node.ports[self.port_co_name].tx_output(self.basis_list)
        
        bob_bases = self.bob_bases
        print(f"[Alice] Got Bob's bases: {len(bob_bases)} bits")
        
        # finalise key output by matching bases
        self.key = [bit for i, bit in enumerate(self.bit_list) if self.basis_list[i] == bob_bases[i]]
        print(f"[Alice] Sifted key: {len(self.key)} bits")


    def gen_qubits(self):
        print("[Alice] Creating and starting clock")
        clock = Clock("[A: Clock]", frequency=self.source_freq, max_ticks=self.photon_count)
        try:
            clock.ports["cout"].connect(self.a_source.ports["trigger"])
        except Exception as e:
            print("[Alice] Clock connect failed: ", e)
            
        clock.start()
        print("[Alice] Clock started")


    def run(self):
        """
        Run Alice's protocol in full
        """
        self.gen_qubits()
        print("[Alice] Waiting for photon batch to send...")
        port = self.node.ports[self.port_ci_name]
        yield self.await_port_input(port)
        print("[Alice] Photons sent, now basis exchange")

        # # NEW: Await Bob's bases first (he sends after measuring)
        # print("[Alice] Waiting for Bob's bases before sending mine...")
        # port = self.node.ports[self.port_ci_name]
        # yield self.await_port_input(port)
        self.bob_bases = port.rx_input().items  # Receive and store
        print(f"[Alice] Got Bob's bases: {len(self.bob_bases)} bits")

        # Now send ours and sift
        self.basis_reconciliation()
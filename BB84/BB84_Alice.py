import netsquid as ns

from netsquid.protocols import NodeProtocol
from netsquid.components import QSource
from netsquid.components.qsource import SourceStatus

import sys
scriptpath = "lib/"
sys.path.append(scriptpath)
from lib.functions import rng_bin_lst, SinglePhotonSource



class AliceProtocol(NodeProtocol):
    """
    Protocol to run on Alice-type node in point-to-point BB84.

    Attributes:
        node            netsquid.components.node.Node object to host protocol
        photon_count    number of photons to be transmitted
        port_qo_name    name of quantum out port on `node`
        port_co_name    name of classical out port on `node`
        port_ci_name    name of classical in port on `node`
        basis_list      list of basis choices for photon string (0 = Z-basis, 1 = X-basis)
        bit_list        list of bit choices for photon string
        key             storage for key output
        source_Qlist    list of qubits emitted by attached photon source
        source_freq     frequency of attached photon source in Hz

    Parameters:
        portNames       list of node ports to be stored in protocol
        sourceEff       efficiency of attached photon source
    """


    def __init__(self, node, photonCount, sourceFreq, portNames=["A.Q.Out","A,C.Out","A.C.In"], sourceEff=1):
        super().__init__()
        self.node         = node
        self.photon_count = photonCount
        self.port_qo_name = portNames[0]
        self.port_co_name = portNames[1]
        self.port_ci_name = portNames[2]
        self.basis_list   = rng_bin_lst(photonCount)
        self.bit_list     = rng_bin_lst(photonCount)
        self.key          = []
        self.source_Qlist = []
        self.source_freq  = sourceFreq

        # attaching a lib.functions.SinglePhotonSource object external to the node and handling output with store_source_output method
        self.a_source = SinglePhotonSource("[A: SPS]", sourceFreq, efficiency=sourceEff, status=SourceStatus.EXTERNAL)
        self.a_source.ports["qout0"].bind_output_handler(self.store_source_output)


    def encode_and_send(self):
        """
        Encode basis and bit and send batch on quantum port
        """
        for i, q in enumerate(self.source_Qlist):
            basis, bit = self.basis_list[i], self.bit_list[i]
            if basis: ns.H(q)
            if bit: ns.X(q)
        self.node.ports[self.port_qo_name].tx_output(self.source_Qlist)


    def store_source_output(self, qubit):
        """
        Store qubit (photon) output in list to be batched to output port via the self.source_Qlist property
        
        Parameters:
            qubit       photon generated by attached SPS
        """
        self.source_Qlist.append(qubit.items[0])

        # if our quantum outbound list is the same size as the photon count we release it and clear
        if len(self.source_Qlist) == self.photon_count:
            self.encode_and_send()
            self.source_Qlist = []


    def basis_reconciliation(self):
        """
        Send basis choices to Bob, receive his and sift common bits into self.key
        """
        # send to Bob
        self.node.ports[self.port_co_name].tx_output(self.basis_list)
        
        # identify classical in port and await Bob's basis list
        port = self.node.ports[self.port_ci_name]
        yield self.await_port_input(port)
        bob_bases = port.rx_input().items
        
        # finalise key output by matching bases
        self.key = [bit for i, bit in enumerate(self.bit_list) if self.basis_list[i] == bob_bases[i]]


    def run(self):
        """
        Run the protocol in full
        """
        # generate photons and wait for completion
        for _ in range(self.photon_count):
            self.a_source.generate()
            yield self.wait(self.source_freq ** -1)

        # wait for final batch to send
        yield self.wait(10 * (self.source_freq ** -1))

        # wait for basis sifting to occur
        yield from self.basis_reconciliation()
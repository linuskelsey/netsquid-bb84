import netsquid as ns

from netsquid.protocols import NodeProtocol
from netsquid.components import Clock
from netsquid.components.qsource import SourceStatus

import sys
scriptpath = "lib/"
sys.path.append(scriptpath)
from lib.functions import rng_bin_lst, SinglePhotonSource



class EndNodeProtocol(NodeProtocol):
    """
    Protocol to run on End User node in point-to-point BB84.

    Attributes:
        node            netsquid.components.node.Node object to host protocol
        photon_count    number of photons to be transmitted
        port_qo_name    name of quantum out port on `node`
        port_co_name    name of classical out port on `node`
        port_ci_name    name of classical in port on `node`
        basis_list      list of basis choices for photon string (0 = Z-basis, 1 = X-basis)
        bit_list        list of bit choices for photon string
        key             storage for key output
        q_source        ====
        q_list          list of qubits emitted by attached photon source
        source_freq     frequency of attached photon source in Hz
        mask            ====
        flipper         ====

    Parameters:
        sourceEff       ====
        portNames       ====
    """
    def __init__(self, node, name, photonCount, sourceFreq, sourceEff=1, portNames=["Q.Out", "C.Out", "C.In"]):
        super().__init__()
        # distinguish node on which the protocol runs
        self.node = node
        self.name = name.title()
        # number of photons to be transmitted to relay
        self.photon_count = photonCount
        # Quantum out port to relay; Classical in/out port from/to relay - no A <-> B comms required
        self.port_qo_name = portNames[0]
        self.port_co_name = portNames[1]
        self.port_ci_name = portNames[2]
        # basis and bit list for transmission
        self.basis_list = rng_bin_lst(self.photon_count)
        self.bit_list = rng_bin_lst(self.photon_count)
        # key
        self.key = self.bit_list.copy()
        # source and handling for source
        self.q_source = SinglePhotonSource(f"[{self.name[0]}: SPS]", sourceFreq, efficiency=sourceEff, status=SourceStatus.EXTERNAL)
        self.q_source.ports["qout0"].bind_output_handler(self.store_source_output)
        self.source_freq = sourceFreq
        self.source_eff = sourceEff
        # qubit list for batched released
        self.q_list = []
        # mask for bit flips and discards
        self.mask = []
        # boolean to flip bits or not
        self.flipper = False
        # end time for timing data
        self.end_time = None


    def store_source_output(self, qubit):
        """
        Store qubit (photon) output in list to be batched to output port via the self.q_list property
        
        Parameters:
            qubit       photon generated by attached SPS
        """
        self.q_list.append(qubit.items[0])

        # if our quantum outbound list is the same size as the photon count we release it and clear
        if len(self.q_list) == self.photon_count:
            self.encode_and_send()
            self.q_list = []

    
    def encode_and_send(self):
        """
        Encode basis and bit and send batch on quantum port
        """
        for i, q in enumerate(self.q_list):
            basis, bit = self.basis_list[i], self.bit_list[i]
            if bit: ns.qubits.operate(q, ns.X)
            if basis: ns.qubits.operate(q, ns.H)
        self.node.ports[self.port_qo_name].tx_output(self.q_list)


    def gen_qubits(self):
        """
        Create an external clock attaching to the SPS that tells it when to emit.
        """
        clock = Clock(f"[{self.name[0]}: Clock]", frequency=self.source_freq, max_ticks=self.photon_count)
        try:
            clock.ports["cout"].connect(self.q_source.ports["trigger"])
        except Exception as e:
            print(f"[{self.name}] Clock connect failed: ", e)
            
        clock.start()


    def discard_non_measurements(self):
        """
        Discard bits based on non-measurements
        """
        port = self.node.ports[self.port_ci_name]
        yield self.await_port_input(port)

        # collect measurements results
        self.meas = port.rx_input().items

        # discard non-measurements
        for i, m in enumerate(self.meas):
            if m == 0:
                self.key[i] = "x"


    def discard_basis_mismatch(self):
        """
        Discard bits based on basis mismatch
        """
        port = self.node.ports[self.port_ci_name]
        yield self.await_port_input(port)

        # collect discard list of indices
        discard = port.rx_input().items

        # discard basis mismatches
        for i in discard:
            self.key[i] = "x"


    def flip(self):
        """
        Flip bits in diagonal, psi plus case
        """
        for i, m in enumerate(self.meas):
            if m == 1 and self.basis_list[i] == 1:
                if isinstance(self.key[i], int):
                    self.key[i] = (self.key[i] + 1) % 2


    def discard(self):
        """
        Remove discarded bits from final key list
        """
        key_new = []
        for b in self.key:
            if b == 0 or b == 1:
                key_new.append(b)

        self.key = key_new


    def run(self):
        """
        Run EndNodeProtocol.
        """
        # prepare and send qubits to relay
        self.gen_qubits()

        # receive BSMs and discard non-measurementss
        yield from self.discard_non_measurements()

        # send bases to Charlie
        self.node.ports[self.port_co_name].tx_output(self.basis_list)

        # receive basis matching and sift
        yield from self.discard_basis_mismatch()

        # flip by measurement results
        if self.flipper:
            self.flip()

        # final key list without discarded bits
        self.discard()
        self.end_time = ns.sim_time(magnitude=ns.NANOSECOND)